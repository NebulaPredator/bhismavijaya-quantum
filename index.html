<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bhishma Vijaya Quantam</title>

<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

<style>
:root {
  --primary: #00f0ff;
  --secondary: #ff3c00;
  --bg-dim: rgba(0, 10, 15, 0.75);
  --glow: 0 0 15px rgba(0,240,255,0.4);
}

body {
  margin: 0;
  background: #000;
  overflow: hidden;
  font-family: 'Orbitron', sans-serif;
  color: var(--primary);
}

#start_overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle, #001a20 0%, #000 100%);
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 1000;
}

#start_btn {
  padding: 20px 45px;
  background: rgba(0,240,255,0.05);
  border: 1px solid var(--primary);
  color: var(--primary);
  cursor: pointer;
  font-size: 16px;
  letter-spacing: 4px;
}

#input_video {
  position: absolute;
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  transform: scaleX(-1);
  filter: contrast(1.1) brightness(0.9) saturate(1.3) sepia(0.1);
  z-index: 1;
}

#three_canvas { position:absolute; inset:0; z-index:5; pointer-events:none; }
#biometric_canvas { position:absolute; inset:0; z-index:10; pointer-events:none; transform:scaleX(-1); }
</style>
</head>

<body>

<div id="start_overlay">
  <div style="font-size: 9px; letter-spacing:8px;">BHISHMA VIJAYA QUANTAM</div>
  <button id="start_btn">CONNECT_INTERFACE</button>
</div>

<video id="input_video" autoplay playsinline></video>
<canvas id="three_canvas"></canvas>
<canvas id="biometric_canvas"></canvas>

<script type="module">

const GRID_SIZE = 1.2;
const PINCH_THRESHOLD = 0.05;
const BUILD_COOLDOWN = 15;

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 25;

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById('three_canvas'),
  antialias: true,
  alpha: true
});

renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);

const voxelGroup = new THREE.Group();
scene.add(voxelGroup);

scene.add(new THREE.AmbientLight(0xffffff, 0.5));

const spotlight = new THREE.PointLight(0x00f0ff, 1.2);
spotlight.position.set(0,10,15);
scene.add(spotlight);

const placedVoxels = new Map();
let lastBuildTime = 0;

function createVoxel(x,y,z){
  const geo = new THREE.BoxGeometry(
    GRID_SIZE*0.96,
    GRID_SIZE*0.96,
    GRID_SIZE*0.96
  );

  const mat = new THREE.MeshPhongMaterial({
    color: 0x000a0f,
    emissive: 0x00f0ff,
    emissiveIntensity: 0.35,
    transparent: true,
    opacity: 0.88,
    shininess: 100
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x,y,z);

  return mesh;
}

const handsPipe = new Hands({
  locateFile: (file) =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

handsPipe.setOptions({
  maxNumHands: 2,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

handsPipe.onResults(onResults);

function onResults(results){
  if(!results.multiHandLandmarks) return;

  const hands = { Left:null, Right:null };

  results.multiHandedness.forEach((h,i)=>{
    hands[h.label] = results.multiHandLandmarks[i];
  });

  if(hands.Right){
    const pinch =
      Math.hypot(
        hands.Right[4].x - hands.Right[8].x,
        hands.Right[4].y - hands.Right[8].y
      ) < PINCH_THRESHOLD;

    const worldPos = new THREE.Vector3(
      (0.5 - hands.Right[8].x)*30,
      (0.5 - hands.Right[8].y)*20,
      -hands.Right[8].z*35
    );

    const gx = Math.round(worldPos.x/GRID_SIZE)*GRID_SIZE;
    const gy = Math.round(worldPos.y/GRID_SIZE)*GRID_SIZE;
    const gz = Math.round(worldPos.z/GRID_SIZE)*GRID_SIZE;

    const key = `${gx},${gy},${gz}`;

    if(pinch && Date.now()-lastBuildTime>BUILD_COOLDOWN*20){
      if(!placedVoxels.has(key)){
        const voxel = createVoxel(gx,gy,gz);
        voxelGroup.add(voxel);
        placedVoxels.set(key,voxel);
        lastBuildTime = Date.now();
      }
    }
  }
}

document.getElementById('start_btn').onclick = () => {
  document.getElementById('start_overlay').style.display = 'none';

  new Camera(
    document.getElementById('input_video'),
    {
      onFrame: async () => {
        await handsPipe.send({
          image: document.getElementById('input_video')
        });
      },
      width:1280,
      height:720
    }
  ).start();
};

function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
